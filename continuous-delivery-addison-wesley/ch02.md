# Quotes

1. If you don’t have absolutely every source artifact of your project in version control, you won’t enjoy any of the benefits of the practices that we discuss to reduce your software’s cycle time and increase its quality.
2. Configuration information can be injected in the application at either:

   * Build time (inside binaries)
   * Packaging time (inside JARs)
   * Deployment time
   * Run time
3. Generally, we consider it bad practice to inject configuration information at build or packaging time. This follows from the principle that you should be able to deploy the same binaries to every environment so you can ensure that the thing that you release is the same thing that you tested. The corollary of this is that anything that changes between deployments needs to be captured as configuration, and not baked in when the application is compiled or packaged
4. It is often important to keep the actual configuration information specific to each of your application’s testing and production environments in a repository separate from your source code. This information generally changes at a different rate to other version-controlled artifacts. However, if you take this route, you will have to be careful to track which versions of configuration information match with which versions of the application
5. The following are few use-cases to consider when modeling configuration information:
   * Adding a new environment
   * Creating a new version of the application
   * Promoting a new version from one enivronment to another
   * Relocating a database server (E.g. if your DEV/SIT environments use the same DB server, updating the server host should be a simple processes as opposed to changing the hostname multiple times)
6. In the same way that your application and build scripts need testing, so do your configuration settings. There are two parts to testing configuration:
	* The first stage is to ensure that references to external services in your configuration settings are good. You should, as part of your deployment script, ensure that the messaging bus you are configured to use is actually up and running at the address configured, and that the mock order fulfillment service your application expects to use in the functional testing environment is working. At the very least, you could ping all external services. Your deployment or installation script should fail if anything your application depends on is not available—this acts as a great smoke test for your configuration settings.
	* The second stage is to actually run some smoke tests once your application is installed to make sure it is operating as expected. This should involve just a few tests exercising functionality that depends on the configuration settings being correct. Ideally, these tests should stop the application and fail the installation or deployment process if the results are not as expected.
7. One of the most important tasks is to keep a catalogue of all the configuration options that each of your applications has, where they are stored, what their lifecycle is, and how they can be changed. If possible, such information should be generated automatically from each application’s code as part of the build process. But where this is not possible, it should be collected in a wiki or other document management system.
8. The principle to bear in mind when managing the environment that your application runs in is that the configuration of that environment is as important as the configuration of the application. If, for example, your application depends on a messaging bus, the bus needs to be configured correctly or the application will not work.
9. There are two principles that, as we have found, form the basis of an effective configuration management strategy: Keep binary files independent from configuration information, and keep all configuration information in one place.
10. It should not be possible for anybody to make a change to production environment without going through your organization’s change management process -- even a tiny change could break it. A change must be tested before it goes into production, and for that it should be scripted and checked into version control. Then, once the change has been approved, it can be rolled out to the production environments in an automated fashion. In this sense, a change to your environment is just like a change to your software. It has to go through your build, deploy, test, and release process in exactly the same way as a change to the application’s code. In this respect, testing environments should be treated the same as production environments.
11. 
