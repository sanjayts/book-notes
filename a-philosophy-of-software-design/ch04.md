# Modules Should Be Deep

1. In modular design, a software system is decomposed into a collection of modules that are relatively independent. Modules can take many forms, such as classes, subsystems, or services. The goal of modular design is to minimize the dependencies between modules.
2. In order to manage dependencies, we think of each module in two parts: an interface and an implementation. The interface consists of everything that a developer working in a different module must know in order to use the given module.
3. The best modules are those whose interfaces are much simpler than their implementations. If a module’s interface is much simpler than its implementation, there will be many aspects of the module that can be changed without affecting other modules.
4. The interface to a module contains two kinds of information: formal and informal.
5. The formal parts of an interface are specified explicitly in the code, and some of these can be checked for correctness by the programming language.
6. The informal parts are not specified in a way that can be understood or enforced by the programming language. They include its high-level behavior, such as the fact that a function deletes the file named by one of its arguments. If there are constraints on the usage of a class (perhaps one method must be called before another), these are also part of the class’s interface. In general, if a developer needs to know a particular piece of information in order to use a module, then that information is part of the module’s interface. The informal aspects of an interface can only be described using comments, and the programming language cannot ensure that the description is complete or accurate.
7. The term abstraction is closely related to the idea of modular design. An abstraction is a simplified view of an entity, which omits unimportant details.
8. An abstraction can go wrong in two ways. First, it can include details that are not really important; when this happens, it makes the abstraction more complicated than necessary, which increases the cognitive load on developers using the abstraction. The second error is when an abstraction omits details that really are important. This results in obscurity: developers looking only at the abstraction will not have all the information they need to use the abstraction correctly.
9. The best modules are those that provide powerful functionality yet have simple interfaces -- also called as "deep modules".
10. A shallow module is one whose interface is complicated relative to the functionality it provides. Shallow modules don’t help much in the battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost of learning and using their interfaces. Small modules tend to be shallow.
11. The extreme of the “classes should be small” approach is a syndrome I call classitis, which stems from the mistaken view that “classes are good, so more classes are better.” In systems suffering from classitis, developers are encouraged to minimize the amount of functionality in each new class: if you want more functionality, introduce more classes. Classitis may result in classes that are individually simple, but it increases the complexity of the overall system. Small classes don’t contribute much functionality, so there have to be a lot of them, each with its own interface.
12. Providing choice is good, but interfaces should be designed to make the common case as simple as possible which is not followed by the Java IO standard library (e.g. it requires creation of 3 objects, FileInputStream, BufferedInputStream and ObjectInputStream to read a serialized object in a buffered manner!)
