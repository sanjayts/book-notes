# Nature Of Complexity

* Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.
* The overall complexity of a system (`C`) is determined by the complexity of each part `p` (`cp`) weighted by the fraction of time developers spend working on that part (`tp`). Isolating complexity in a place where it will never be seen is almost as good as eliminating the complexity entirely.
* Complexity is more apparent to readers than writers. If you write a piece of code and it seems simple to you, but other people think it is complex, then it is complex.
* Symptoms of Complexity:
  1. Change Amplification: A seemingly simple change requires code modifications in many different places. One of the goals of good design is to reduce the amount of code that is affected by each design decision, so design changes don’t require very many code modifications.
  2. Cognitive Load: This refers to how much a developer needs to know in order to complete a task. Sometimes an approach that requires more lines of code is actually simpler, because it reduces cognitive load. E.g. using a framework would take around 5 lines to achieve something but adds cognitive load in terms of understanding what those 5 lines do. It's quite possible that a non-framework based 40 line solution might have less cognitive load than the 5 line one.
  3. Unknown unknowns: It's not clear which pieces of code must be modified to complete a given task or what information a developr must have to carry out a task successfully.
* Of the three manifestations of complexity, unknown unknowns are the worst. One of the most important goals of good design is for a system to be obvious. An obvious system is one where a developer can make a quick guess about what to do, without thinking very hard, and yet be confident that the guess is correct.
* There are 2 causes of complexity:
  1. Dependencies: A dependency exists when a given piece of code cannot be understood and modified in isolation; the code relates in some way to other code, and the other code must be considered and/or modified if the given code is changed. Dependencies are a fundamental part of software and can’t be completely eliminated. However, one of the goals of software design is to reduce the number of dependencies and to make the dependencies that remain as simple and obvious as possible.
  2. Obscurities:  Obscurity occurs when important information is not obvious.For example, if a new error status is added to a system, it may be necessary to add an entry to a table holding string messages for each status, but the existence of the message table might not be obvious to a programmer looking at the status declaration.
* Dependencies lead to change amplification and a high cognitive load. Obscurity creates unknown unknowns, and also contributes to cognitive load. If we can find design techniques that minimize dependencies and obscurity, then we can reduce the complexity of software.
* The incremental nature of complexity makes it hard to control. It’s easy to convince yourself that a little bit of complexity introduced by your current change is no big deal. However, if every developer takes this approach for every change, complexity accumulates rapidly.
